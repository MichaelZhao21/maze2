The running time of the program can be limited to O((mn)^2). Although this is an unreasonably high bound, the average case (although unknown) should not approach this limit.

The algorithm I used was a BFS that iterated through all paths of minimum cost until none were left. For each node that we visit, we will check the top, left, bottom, and right cells to see if the cost going from the current cell will be less than the current cost going from some other cell. If this is true, we set the parent value of the next cell to the current cell. Then, we add that cell to the Priority Queue and pop the next element from the queue to visit. This will continue until the queue is completely empty.

The first tile, excluding the starting tile, can be visited only once. The second tile, can only be visited once as all other costs for the tiles will be more. Since we go in order of priority (natural sorting order), we will always process the least-valued node. Because of this, each cell should only be visited a maximum of n * m times due to the fact that there can be n * m possible cells that will propagate updates the current cell. In reality, the visits should never approach n * m, but I am unable to bound it any further. Since there are a total of n * m cells that can be visited in n * m time, the bound for the running time is therefore O((n*m)^2).
